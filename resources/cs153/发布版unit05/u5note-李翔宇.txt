1.注意区间结束开始是否可重叠
2.区间贪心算法：
（1）输入，按结束时间从小到大排序，如相等按开始时间从小到大排序。
（2）x初始化为-m（m为间隔时间），如没有间隔则初始化为-1
（3）一个活动过后，计数器++，x初始化为结束时间，找下一个活动（起始时间>x）
（4）计数器为最多参加活动数量。
3.容器解决方案（输入方式不太顺，改成了cin>>d.s>>d.t;一次性输入）


#include<bits/stdc++.h>
#define N 105
using namespace std;
struct food{int s,t;};
struct cmp{
	bool operator()(const food &a,const food &b)const{
		return a.t<b.t||a.t==b.t&&a.s<b.s;
	}
}; 
food d;
int n,i,x,ans;
int main(){
	multiset<food,cmp> ms;
	multiset<food,cmp>::iterator it;
	cin>>n;	
	for(i=0;i<n;i++){
	    cin>>d.s>>d.t;
	    ms.insert(d);
	}
	x=-1; ans=0;
	for(it=ms.begin();it!=ms.end();it++)
		if((*it).s>=x) {
			ans++;
			x=(*it).t;
		}
	cout<<ans<<endl;	
	return 0;
}
